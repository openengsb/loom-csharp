<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="developer.configuration" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>Developer Manual</title>
    <section>
        <title>Introduction and Idea</title>
        <para> The .Net bridge has been invented out of the need from a Java to .Net converter for
            the OpenEngSB project. More specific, the .Net bridge is a connector for a arbitrary
            domain and converts the recieved data to the .Net specification. Generally this is don
            by seriaisation and deserialisation the received/send objects to json, which is
            explained in <xref xlink:href="#General"/>. Furthermore, two proxy are needed, which will be explained in
            <xref xlink:href="#DomainProxy"/> and <xref xlink:href="#DomainReverseProxy"/> </para>
        <para>The following picture should represent the key components and the interaction with the
            domain.</para>
        <para><inlinemediaobject>
                <imageobject>
                    <imagedata fileref="graphics/komponent.png" align="center"/>
                </imageobject>
            </inlinemediaobject></para>
        <para>The following sequence diagramm shoes the interaction between the .Net bridge and a
            domain</para>
        <para><inlinemediaobject>
                <imageobject>
                    <imagedata fileref="graphics/sequence.png" align="center"/>
                </imageobject>
            </inlinemediaobject></para>        
    </section>
    <section xml:id="General">
        <title>General structure</title>
        <para>The .Net Bridge has the following sturcture</para>
        <para><inlinemediaobject>
                <imageobject>
                    <imagedata fileref="graphics/structure.png" align="center" annotations=""/>
                </imageobject>
            </inlinemediaobject></para>
        <para>If one OpenEngSB version has big changes, like from 2.4.2 to 3.0.0 then a new
            subfolder in the Implementation should be created. This has the advantage, that the .Net
            Bridge will be compatible to earlier version. The structure in the OpenEngSB versions
            folders are always the same. First there is the <emphasis role="italic"
                >RealDomanFactory</emphasis>, which take care of the initialisation of the proxys.
            Next the folder Remote contains the classes <emphasis role="italic"
                >DomainProxy</emphasis>, <emphasis role="italic">DomainReveseProxy</emphasis> and
            the folder <emphasis role="italic">RemoteObjects</emphasis>. In the folder RemoteObjects
            are the Objects, which will be generated by a Json Converter and used to handle the
            method invocation. These invocation can be local or on the domain. Further information
            will be presented in the proxy sections. Last but not least the <emphasis role="italic"
                >DomainReverseProxy</emphasis> is handling the answers from the domain and invokes
            the local methods. In opposite, the DomainProxy handels the communication with the
            domain, to invoke a method on it. It should also be mentioned, that the
            RegistrationFunctions is a partial class, which has to be implemented in the localDomain
            (See Chapter How to use). These methods are handling the registration procedure for a
            connector (v.2.4.2) and the get alive request. For further details on the registration
            procedure for a connector, please the OpenEngSB documentation. <link
                xlink:href="http://openengsb.org/index/documentation.html"
            >documentation</link>.</para>
    </section>
    <section xml:id="DomainProxy">
        <title>DomainProxy</title>
        <para>This section will explain who a method is invoked and transfer to the domain. This
            classes implements the .Net library <code>RealProxy</code> (<uri><link
                    xlink:href="http://msdn.microsoft.com/en-us/library/system.runtime.remoting.proxies.realproxy(v=vs.110).aspx"
                    >Microsoft .Net</link></uri>). The key method of this class is the
            <programlisting>IMessage Invoke(IMessage msg)</programlisting>Method. If a method from a
            Interface/Type, which has been indicted in the constructor is invoked then this method
            call will be forwarded to this method. All the parameters from this method are
            represented in msg. In the next step, the parameters from the method and some additional
            information, like for example the <code>serviceId</code> are converted to a
                <code>MethodCallMessage</code> Object (version 3.0.0) or
                <code>MethodCallRequest</code> Object (version 2.4.2). Next this object is
            serialised by a Json Marshaller and the send to the domain.</para>
        <para>Last but not least, the answer from the domain is converted to a
                <code>MethodResultMessage</code>, which contains the parameters and the method name
            from a local method (Type is also indicated in the constructor). The invocation of the
            method is done over reflection.</para>
    </section>
    <section xml:id="DomainReverseProxy">
        <title>DomainReverseProxy</title>
        <para>The DomainReverseProxy is waiting for messages from the Domain. These messages are
            then interpreted and converted to method calls. The key class here is the
                <code>Listen</code> method. This method runs in a thread, because the messages from
            the Domain can be received at any time (Abstract, the DomainReverseProxy should react
            like a Domain).</para>
        <para>If the <code>Listen</code> method receives datas, it first converts it over a Json
            Marshaller in a <code>MethodCallMessage</code> (version 3.0.0) or
                <code>MethodCallRequest</code> (version 2.4.2). In the next step, it invokes the
            method in the local domain over reflection (Interface/Type has been indicated in the
            constructor). The result is then created to a <code role="italic"
                >MethodResultMessage</code> object and if indicated from the recieved domain answer
            transmitted to the domain. </para>
        <para>Note: Like in the DomainProxy, the generation of MethodResultMessage and
            MethodCallRequest consist not only the parameters for the method call but also other
            information like ServiceId,Queue, ...</para>
    </section>
</chapter>
