<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="developer.configuration" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>Developer Manual</title>
    <section>
        <title>Introduction and Idea</title>
        <para> The .Net bridge has been invented out of the need from a Java to .Net converter for
            the OpenEngSB project. More specific, the .Net bridge is a connector for a arbitrary
            domain and converts the recieved data to the .Net specification. Generally this is don
            by seriaisation and deserialisation the received/send objects to json, which is
            explained in <xref xlink:href="#General"/>. Furthermore, two proxy are needed, which will be explained in
            <xref xlink:href="#DomainProxy"/> and <xref xlink:href="#DomainReverseProxy"/> </para>
        <para>The following picture should represent the key components and the interaction with the
            domain.</para>
        <para><inlinemediaobject>
                <imageobject>
                    <imagedata fileref="graphics/komponent.png" align="center"/>
                </imageobject>
            </inlinemediaobject></para>
        <para>The following sequence diagramm shoes the interaction between the .Net bridge and a
            domain</para>
        <para><inlinemediaobject>
                <imageobject>
                    <imagedata fileref="graphics/sequence.png" align="center"/>
                </imageobject>
            </inlinemediaobject></para>        
    </section>
    <section xml:id="General">
        <title>General structure</title>
        <para>The .Net Bridge has the following sturcture</para>
        <para><inlinemediaobject>
                <imageobject>
                    <imagedata fileref="graphics/structure.png" align="center" annotations=""/>
                </imageobject>
            </inlinemediaobject></para>
        <para>If  from one OpenEngSB version to an other some big changes happend, like from
            2.4.2 to 3.0.0 then a new folder subfolder in the Implementation should be created.
            These has the advanteg, that the .Net Bridge will be compatible to earlier version. The
            structure in the OpenEngSB versions folders are always the same. First there is the
                <code>RealDomanFactory</code>, which take care of the
            initialisation of the proxys. Next the folder Remote contains the classes <code>DomainProxy</code> , <code role="italic"
                >DomainReveseProxy</code>and the folder RemoteObjects. In the folder
            RemoteObjects are the Objects, which will be generated by a Json Converter and used to
            handle the method invocation. These invocation can be local or on the domain. Further
            information will be presented in the proxy sections. Last but not least the <code>DomainReverseProxy</code> is handling the answers from the domain
            and invokes the local methods. In opposite, the <code role="italic"
                >DomainProxy</code> handels the communication with the domain, to invoke a
            method on it. </para>
        <para>It sould also be mentioned, that the <code role="italic">RegistrationFunctions</code>
            is a partial class, which has to be implemented in the localDomain (See Chapter How to
            use). These methods are handling the registration procedure for a connector. For further
            details on the regirstration procedure for a connector, please the OpenEngSB  <link
                xlink:href="http://openengsb.org/index/documentation.html"
            >documentation</link>.</para>
    </section>
    <section xml:id="DomainProxy">
        <title>DomainProxy</title>
        <para>This section will explain, who a method is invoked and transfert to the domain. This
            classes implements the .Net library <code>RealProxy</code> (<uri><link
                    xlink:href="http://msdn.microsoft.com/en-us/library/system.runtime.remoting.proxies.realproxy(v=vs.110).aspx"
                    >Microsoft .Net</link></uri>). The key method of this class is the
            <programlisting>IMessage Invoke(IMessage msg)</programlisting> Method. If a method from
            a Interface/Type, which has been indiced in the constructor is invoked then this mehtod
            call will be fowarded to this method. All the parameters from this method are
            represended in msg.</para>
        <para>In the next step, the the parameters from the method and some additional
            information, like for example the <code>serviceId</code> are
            converted to a <code>SecureMethodCallRequest</code> Object
            (version 3.0.0) or <code>MethodCallRequest</code> Object (version
            2.4.2). Next this object is serialised by a Json Marshaller and the send to the
            domain.</para>
        <para>Last but not least, the answer from the domain is converted to a <code>MethodResultMessage</code>, which contains the parameters and the
            method name from a local methods (Type is also indicated in the constructor). The
            invocation of the method is done over reflection.</para>
    </section>
    <section xml:id="DomainReverseProxy">
        <title>DomainReverseProxy</title>
        <para>The DomainReverseProxy is waiting for messages from the Domain. These messages are then
        interprated and converted to method calls.</para>
        <para>The key class here is the <code>Listen</code> method. This method
        runs in a thread, because the messages from the Domain can be received at any time
        (Abstract, the DomainReverseProxy should reacte like a Domain).</para>
        <para>If the <code>Listen</code> method receives datas, it first converts
        it over a Json Marshaller in a <code>SecureMethodCallRequest</code>
        (version 3.0.0) or <code>MethodCallRequest</code> (version 2.4.2). In
        the next step, it invokes the method in the local domain over reflection (Interface/Type has
        been indicated in the constructor). The result is then created to a <code role="italic"
            >MethodResultMessage</code> object and if indicated from the recieved domain answer
        transmitted to the domain. </para>
        <para>Note: Like in the DomainProxy, the generation of
        MethodResultMessage,SecureMethodCallRequest and MethodCallRequest consist not anly the
        paramers for the method call but also other information like ServiceId,Queue, ...</para>
    </section>
</chapter>
